from Crypto.Util.number import *

nbits, rbits = 256, 240
e = 65537

N = 9554594442777956156176575410111600195877530714413341173170684511629274299512228887424722865581070074211220073375779601169613670191773041155190935992384503
A = 7461675696855485192498077806574979378047894821983865815839657530422849448689515297532903764658811059355302125460753210703381969189642182146350648776660800
B = 9434068242398921342211002064324465916062393376458086291548511274573416249033581548777010110839749584250133350250249137285226277646494093017384578041939028
X = 2307392417341885799596739085844264179388900683812340084993018869836755199903738815754854447496349782908851273354288563878127053152518798853361786098790086
Y = 8088051586635397321367808834017662405062741020871047546836555202710334915714609790269314128181137793132378471121286052630286539914489786777057686952350201
ct = 2820607551983845230812303368005639695109422590147246290345429705320752894016316200148900472636430606697622288535569496994810765077588892270595919635187359

zmodn = Zmod(N)
P.<x> = PolynomialRing(zmodn,implementation = 'NTL')
P.<y> = PolynomialRing(zmodn,implementation = 'NTL')

# (1/d - epsilon) * nbits = rbits
## epsilon = 1/32 

f = (e * x + A)^2 - X
root1 = f.monic().small_roots(X = 2^240 ,epsilon = 1/32)

if len(root1) != 0:
	print("Found x :",root1[0])

f2 = (e * y + B)^2 - Y
root2 = f2.monic().small_roots(X = 2^240, epsilon = 1/32)

if len(root2) != 0:
	print("Found y :",root2[0])

val1 = ( pow(A,int(root2[0]),N) - pow( inverse(int(root1[0]),N), (int(root1[0])*int(root2[0])),N) * pow(B,int(root1[0]),N) )%N

print(val1)

q = GCD(int(val1),N)
p = N // q

e = 65537
d = inverse(e,(p-1) * (q-1))

print(long_to_bytes(int(pow(ct,d, N))))

## b'jadeCTF{mithril_is_peril_why_not_copper_with_gcd?}'

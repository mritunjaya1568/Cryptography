# Usually in the grand scheme of RSA, a large e does not necessarily mean that d is small (that is, d<(n**(1/4))/3).
# However, given that this is a CTF style challenge, we can simply ASSUME instead that d is indeed small.
# This opens up the possibility of Wiener's Attack to directly recover d (and p,q if you are interested.)

# In order not to bore you, I offer an OVERSIMPLIFIED algorithm for Wiener's Attack.

# Reference which helped me to understand Wiener's Attack as well: 
# https://sagi.io/crypto-classics-wieners-rsa-attack/

## Begin Wiener's Attack. (wiener.sage)

N = 0x8da7d2ec7bf9b322a539afb9962d4d2ebeb3e3d449d709b80a51dc680a14c87ffa863edfc7b5a2a542a0fa610febe2d967b58ae714c46a6eccb44cd5c90d1cf5e271224aa3367e5a13305f2744e2e56059b17bf520c95d521d34fdad3b0c12e7821a3169aa900c711e6923ca1a26c71fc5ac8a9ff8c878164e2434c724b68b508a030f86211c1307b6f90c0cd489a27fdc5e6190f6193447e0441a49edde165cf6074994ea260a21ea1fc7e2dfb038df437f02b9ddb7b5244a9620c8eca858865e83bab3413135e76a54ee718f4e431c29d3cb6e353a75d74f831bed2cc7bdce553f25b617b3bdd9ef901e249e43545c91b0cd8798b27804d61926e317a2b745
e = 0x86d357db4e1b60a2e9f9f25e2db15204c820b6e8d8d04d29db168c890bc8a6c1e31b9316c9680174e128515a00256b775a1a8ccca9c6936f1b4c2298c03032cda4dd8eca1145828d31466bf56bfcf0c6a8b4a1b2fb27de7a57fae7430048d7590734b2f05b6443ad60d89606802409d2fa4c6767ad42bffae01a8ef1364418362e133fa7b2770af64a68ad50ad8d2bd5cebb99ceb13368fb31a6e7503e753f8638e21a96af1b6498c18578ba89b98d70fa482ad137d28fe701b4b77baa25d5e84c81b26ee9bddf8cbb51a071c60dd57714de379cd4bc14932809ba18524a0a18e4133665cfc46e2c4fcfbc28e0a0957e5513a7307c422b87a6182d0b6a074b4d

expansion=continued_fraction(e/N) # Retrieve the continued fraction expansion of e/N in list form.
converge=expansion.convergents() # Retrieve the convergents of the expansion.
for frac in converge: # For every convergent up to i terms where i is some constant,
    print(frac)
	# We note that since ed ≡ 1 (mod ϕ(N)), there must exist some integer k such that ed = 1 + k*ϕ(N).
	# thus e/ϕ(N) ≈ k/d. (they are NOT equal, just very close)
	# This for loop essentially iterates through the convergents to find the values of k and d that satisfies the approximation. 
	# This is not exactly Wiener's Theorem, but it is how I understand it at the time of writing.
    
	k_p,d_p = frac.numerator(),frac.denominator() # extract candidates for k/d. 
    if k_p==0: continue 
    totient_p=(e*d_p-1)//k_p # By some algebraic manipulation we extract the candidates for ϕ(N)

	# Recall that for RSA, ϕ(N)=(p-1)*(q-1) and N=pq, where p and q are primes.
	# Thus we derive ϕ(N)=N-p-(N/p)+1 => ϕ(N)*p=N*p-p**2-N+p => ...
	# In the end, we receive p**2 - (ϕ(N)-N-1)*p + N = 0.
    p=var('p')
    eq_p=(p**2 + p*(totient_p-N-1)+N==0)
	# The idea is that by solving for p, we can verify that k/d is the right pair corresponding to e/ϕ(N)
    roots_eq=solve(eq_p,p,solution_dict=True)
    
    if len(roots_eq)==2: # Simple Verification
        p_p,q_p=int(p.subs(roots_eq[0])),int(p.subs(roots_eq[1]))
        print(f"Solutions: {p_p} {q_p}")
        if p_p*q_p==N:
            print(f"FOUND!\n\n{p_p}\n\n {q_p}")

# Solutions: 
# p=154815838830735756266839897002132314538675909135249954852542100179590192055257100601759523401409380049463266265323780406554692248012224485469468355325698979825072726357567352976501667578692853621821116743497998613306224857520639271685772211046709014876104481766909036522349223506326852943709940047836080845531 
# q=115507290436804681853972513785855229092334080356874717883434238235532664441400698329642751264652299576298636563034566154936812894976200811116395627642824129881201879664681775402664283913508399125714656956248098339209538838857780042711388040763913184276611985732635893909527514214876581238108724839614805837919
# d=2101331143788522595213090369335412413246726919082932998508639766188316307440584130176331667555770390246514253685122258563932325382110217157935136067104441

# Actual output from my terminal
# (This is k/d) 2000014277091643468577623339801783448304262928780963698951537938097489344220091973560226565880505506366299904328966554767670675274620411348589999352628835/2101331143788522595213090369335412413246726919082932998508639766188316307440584130176331667555770390246514253685122258563932325382110217157935136067104441
# Solutions: 154815838830735756266839897002132314538675909135249954852542100179590192055257100601759523401409380049463266265323780406554692248012224485469468355325698979825072726357567352976501667578692853621821116743497998613306224857520639271685772211046709014876104481766909036522349223506326852943709940047836080845531 115507290436804681853972513785855229092334080356874717883434238235532664441400698329642751264652299576298636563034566154936812894976200811116395627642824129881201879664681775402664283913508399125714656956248098339209538838857780042711388040763913184276611985732635893909527514214876581238108724839614805837919

# The actual decryption (solve.sage)
# Instead of retrieving p and q, after running wiener.sage we can LITERALLY just copy d and decrypt.
from Crypto.Util.number import long_to_bytes

# Note to self: Use RsaCtfTool for future Wiener's Attacks
N = 0x8da7d2ec7bf9b322a539afb9962d4d2ebeb3e3d449d709b80a51dc680a14c87ffa863edfc7b5a2a542a0fa610febe2d967b58ae714c46a6eccb44cd5c90d1cf5e271224aa3367e5a13305f2744e2e56059b17bf520c95d521d34fdad3b0c12e7821a3169aa900c711e6923ca1a26c71fc5ac8a9ff8c878164e2434c724b68b508a030f86211c1307b6f90c0cd489a27fdc5e6190f6193447e0441a49edde165cf6074994ea260a21ea1fc7e2dfb038df437f02b9ddb7b5244a9620c8eca858865e83bab3413135e76a54ee718f4e431c29d3cb6e353a75d74f831bed2cc7bdce553f25b617b3bdd9ef901e249e43545c91b0cd8798b27804d61926e317a2b745
# p=154815838830735756266839897002132314538675909135249954852542100179590192055257100601759523401409380049463266265323780406554692248012224485469468355325698979825072726357567352976501667578692853621821116743497998613306224857520639271685772211046709014876104481766909036522349223506326852943709940047836080845531 
# q=115507290436804681853972513785855229092334080356874717883434238235532664441400698329642751264652299576298636563034566154936812894976200811116395627642824129881201879664681775402664283913508399125714656956248098339209538838857780042711388040763913184276611985732635893909527514214876581238108724839614805837919
d=2101331143788522595213090369335412413246726919082932998508639766188316307440584130176331667555770390246514253685122258563932325382110217157935136067104441
c = 0x6a2f2e401a54eeb5dab1e6d5d80e92a6ca189049e22844c825012b8f0578f95b269b19644c7c8af3d544840d380ed75fdf86844aa8976622fa0501eaec0e5a1a5ab09d3d1037e55501c4e270060470c9f4019ced6c4e67673843daf2fd71c64f3dd8939ae322f2b79d283b3382052d076ebe9bb50b0042f1f7dd7beadf0f5686926ade9fc8370283ead781a21896e7a878d99e77c3bb1f470401062c0e0327fd85da1cf12901635f1df310e8f8c7d87aff5a01dbbecd739cd8f36462060d0eb237af8d613e2d9cebb67d612bcfc353ef2cd44b7ac85e471287eb04ae9b388b66ea8eb32429ae96dba5da8206894fa8c58a7440a127fceb5717a2eaa3c29f25f7

print(long_to_bytes(pow(c,d,N)))
# crypto{s0m3th1ng5_c4n_b3_t00_b1g}
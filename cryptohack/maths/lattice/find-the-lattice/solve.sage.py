

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257 = Integer(7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257); _sage_const_2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800 = Integer(2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800); _sage_const_5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523 = Integer(5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
from Crypto.Util.number import *

# z = int(sqrt(q)//2)
# Ques. -> why this decryption is working ??
# Ans. -> because when we do 
# f * e = (m * f + r * g) mod q
# m < z , f <= z, m * f < q/2
# r <= z , g <=z, r * g <= q/2
# m * f + r * g < q
# so mod q will have no effect
# (f * e) mod q = m * f + r * g
# a = m * f + r * g
# take mod g 
# a  = (m * f) mod g
# now you can find m by taking the inverse of f wrt g
# m = (a * f^(-1)) mod g

def decrypt(q, h, f, g, e):
    a = (f*e) % q
    m = (a*inverse(f, g)) % g
    return m

q,h = map(int,(_sage_const_7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257 , _sage_const_2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800 ))
e = int(_sage_const_5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523 )

# z = int(sqrt(q//2))
# f * h - k1 * q = g
# since this is an SVP problem, because k1 < z, f < z
# 1st vector will be the shortest vector

print("1st attack using LLL")
# 1st method, by using LLL
M = matrix(QQ,_sage_const_2 ,_sage_const_2 )
M[_sage_const_0 ,_sage_const_0 ] = h
M[_sage_const_1 ,_sage_const_0 ] = q
M[_sage_const_0 ,_sage_const_1 ] = _sage_const_1 
M[_sage_const_1 ,_sage_const_1 ] = _sage_const_0 

### h 1
### q 0 

### [h * f - k1 * f = g, f] = [g,f]

Mred = M.LLL()
g,f = Mred[_sage_const_0 ]
g,f = int(g), int(f)

assert GCD(f,g) == _sage_const_1 

flag = decrypt(q,h,f,g,e)
print(long_to_bytes(flag))
print("1st attack done")

print("2nd attack using Gauss reduction")
# 2nd method by using gaussian reduction

def modified_gauss(v1, v2):
    while True:
        if v2 * v2 < v1 * v1:
            v1, v2 = v2, v1
        mu = (v2 * v1) / (v1 * v1)
        # print(mu)
        if mu <= (_sage_const_1 /_sage_const_2 ):
            print("Got reduced basis")
            return v1, v2
        mu = floor(mu)
        v2 = v2 - mu * v1

red1, red2 = modified_gauss(vector(QQ,[h,_sage_const_1 ]), vector(QQ, [q,_sage_const_0 ]))

# 1st vector will be the shortest vector, or SVP
g1, f1 = map(int,red1)
flag2 = decrypt(q,h, f1, g1, e)
print(long_to_bytes(flag))


## flag - b'crypto{Gauss_lattice_attack!}'

# ZZ(g/GF(q)(h))

